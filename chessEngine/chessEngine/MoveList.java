package chessEngine;

import java.util.LinkedList;

/*
 * Class generates all possible moves for a player. Bitboard masks are used to
 * control for legality of moves. Masks were pre-generated by Logic Crazy, some masks
 * are in hex representations to conserve space and readability of code.
 * 
 * Piece position bitboards are generated by BoardGen class. All piece move functions are
 * generalized except pawns due to pawns being direction dependent.
 * 
 * Based on Logic Crazy chess engine: https://www.youtube.com/channel/UCmMjMHTeUEBJJZhxix-N-yg
 */

public class MoveList {
	
	// MASKS
	long fileA=72340172838076673L; // prevent bad pawn moves
    long fileH=-9187201950435737472L; // prevent bad pawn moves
    long filesAB=217020518514230019L; // prevent bad knight moves
    long filesGH=-4557430888798830400L; // prevent bad knight moves
    long rank1=-72057594037927936L; // used for pawn promotion
    long rank8=255L; // used for pawn promotion
    long rank4=1095216660480L; // used for en passant
    long rank5=4278190080L; // used for en passant
    long kingSpan = 460039L;
    long knightSpan = 43234889994L;
    long rankMasks[] = { 
    		0xFFL, 0xFF00L, 0xFF0000L, 0xFF000000L, 0xFF00000000L, 
    		0xFF0000000000L, 0xFF000000000000L, 0xFF00000000000000L
     }; // masks for all ranks used for sliding piece moves (ordered: 1 to 8)
     long fileMasks[] = {
    		 0x101010101010101L, 0x202020202020202L, 0x404040404040404L, 0x808080808080808L,
    		 0x1010101010101010L, 0x2020202020202020L, 0x4040404040404040L, 0x8080808080808080L
     }; // masks for all files used for sliding piece moves (ordered: A to H)
     long diagonalMasks[] = {
    		 0x1L, 0x102L, 0x10204L, 0x1020408L, 0x102040810L, 0x10204081020L, 0x1020408102040L,
    		 0x102040810204080L, 0x204081020408000L, 0x408102040800000L, 0x810204080000000L,
    		 0x1020408000000000L, 0x2040800000000000L, 0x4080000000000000L, 0x8000000000000000L
     }; // masks for all diagonals used for sliding piece moves (ordered: from top left to bottom right)
     long antiDiagonalMasks[] = {
    		 0x80L, 0x8040L, 0x804020L, 0x80402010L, 0x8040201008L, 0x804020100804L, 0x80402010080402L,
    		 0x8040201008040201L, 0x4020100804020100L, 0x2010080402010000L, 0x1008040201000000L,
    		 0x804020100000000L, 0x402010000000000L, 0x201000000000000L, 0x100000000000000L
     }; //masks for all anti-diagonals used for sliding piece moves (ordered: from top right to bottom left)
     
    // GAME STATE
    long occupied; // holds all occupied locations
    long empty; // holds all empty locations on board
    long whiteCaptures; // locations of bP, bN, bB, bR, bQ
    long blackCaptures; // locations of wP, wN, wB, wR, wQ
    long whiteCanGo; // locations clear of wP, wN, wB, wR, wQ, wK, bK
    long blackCanGo; // locations clear of bP, bN, bB, bR, bQ, bK, wK
    long enpassant; // holds location of possible en passant
    LinkedList<String> moveList; // linked list of all possible white moves
    
    /*
     * Constructors
     */
    
    public MoveList() {
    	moveList = new LinkedList<>();
    }
    
    /*
     * Player Moves
     */
    
     public void whiteMoves(long wP, long wN, long wB, long wR, long wQ, long wK, long bP, long bN, long bB, long bR, long bQ, long bK, boolean kSide, boolean qSide) {
    	 // wpMoves() + nMoves() + bMoves() + rMoves() + qMoves() + kMoves()
    	 
    	 occupied = (wP | wN | wB | wR | wQ | wK | bP | bN | bB | bR | bQ | bK);
    	 empty = ~occupied;
    	 whiteCanGo = ~(wP | wN | wB | wR | wQ | wK | bK);
    	 whiteCaptures = (bP | bN | bB | bR | bQ);
    	 wpMoves(wP, bP);
    	 bMoves(wN, whiteCanGo);
    	 rMoves(wR, whiteCanGo);
    	 qMoves(wQ, whiteCanGo);
    	 nMoves(wN, whiteCanGo);
    	 kMoves(wK, whiteCanGo);
    	 cMoves(false, wR, kSide, qSide);
     }
     
     public void blackMoves(long wP, long wN, long wB, long wR, long wQ, long wK, long bP, long bN, long bB, long bR, long bQ, long bK, boolean kSide, boolean qSide) {
    	 // bpMoves() + rankMoves() + fileMoves() + diagonalMoves() + antidiagonalMoves()

    	 occupied = (wP | wN | wB | wR | wQ | wK | bP | bN | bB | bR | bQ | bK);
    	 empty = ~occupied;
    	 blackCanGo = ~(bP | bN | bB | bR | bQ | bK | wK);
    	 blackCaptures = (wP | wN | wB | wR | wQ);
    	 bpMoves(bP, wP);
    	 bMoves(bN, blackCanGo); 
    	 rMoves(bR, blackCanGo);
    	 qMoves(bQ, blackCanGo);
    	 nMoves(bN, blackCanGo);
    	 kMoves(bK, blackCanGo);
    	 cMoves(true, bR, kSide, qSide);
     }
     
     /*
      * Pawns
      */
     // white pawns
     public void wpMoves(long wP, long bP) {
    	 // all moves for white pawns
    	 String move = ""; // store move as x1y1x2y2 before adding to list
    	 long pawnMoves; // bitboard for pawn destinations
    	 long nextMove; // bitboard to test each move
    	 
    	 /*
    	  * Forward Progress
    	  */
    	 
    	 // move forward 1
    	 pawnMoves =(wP >> 8) & empty & ~rank8; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 + 1) + (index % 8) + (index / 8) + (index % 8);
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 // move forward 2
         pawnMoves =(wP >> 16) & empty & (empty >> 8) & rank4; // only allow if path is clear and destination is rank 4
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 + 2) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
    	  * Captures
    	  */
         
    	 // capture left (from white perspective)
         pawnMoves = (wP >> 9) & whiteCaptures & ~rank8 & ~fileH; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 + 1) + (index % 8 + 1) + (index / 8) + (index % 8);
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right (from white perspective)
         pawnMoves = (wP >> 7) & whiteCaptures & ~rank8 & ~fileA; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 + 1) + (index % 8 - 1) + (index / 8) + (index % 8);
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 /*
    	  * Promotions
    	  */
         
         // forward
         pawnMoves = (wP >> 8) & empty & rank8;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
             move += (index % 8) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8) + (index % 8) + "NP"; // no promotion
             moveList.add(move);
             pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture left (from white perspective)
         pawnMoves = (wP >> 9) & whiteCaptures & rank8 & ~fileH;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index % 8 - 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 - 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 - 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 - 1) + (index % 8) + "NP"; // no promotion
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right
         pawnMoves = (wP >> 7) & whiteCaptures & rank8 & ~fileA;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index % 8 + 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 + 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 + 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 + 1) + (index % 8) + "NP"; // no promotion
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 /*
    	  * En passant
    	  */
         // left 
         pawnMoves = (wP << 1) & bP & rank5 & ~fileA & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 move += (index % 8 - 1) + (index  % 8) + "WE";
        	 moveList.add(move);
         }
         // right 
         pawnMoves = (wP >> 1) & bP & rank5 & ~fileH & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 move += (index % 8 + 1) + (index  % 8) + "WE";
        	 moveList.add(move);
         }
     }
     
     // black pawns
     public void bpMoves(long bP, long wP) {
    	 // all moves for black pawns
    	 long pawnMoves; // bitboard for pawn destinations
    	 long nextMove; // bitboard to test each move
    	 String move = ""; // store move as x1y1x2y2 before adding to list
    	 
    	 /*
    	  * Forward Progress
    	  */
    	 
    	 // move forward 1
    	 pawnMoves =(bP << 8) & empty & ~rank1; // see promotions for rank1
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 - 1) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }

         // move forward 2
         pawnMoves =(bP << 16) & empty & (empty << 8) & rank5; // only allow if path is clear and destination is rank 5
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 - 2) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
    	  * Captures
    	  */
         
    	 // capture left (from black perspective)
         pawnMoves = (bP << 9) & blackCaptures & ~rank1 & ~fileA; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 - 1) + (index % 8 - 1) + (index / 8) + (index % 8);
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right (from black perspective)
         pawnMoves = (bP << 7) & whiteCaptures & ~rank8 & ~fileH; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index / 8 - 1) + (index % 8 + 1) + (index / 8) + (index % 8);
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }

         /*
    	  * Promotions
    	  */
         // forward
         pawnMoves = (bP << 8) & empty & rank8;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
             move += (index % 8) + (index % 8) + "qP" // promotion to queen
            		 + (index % 8) + (index % 8) + "rP" // promotion to rook
            		 + (index % 8) + (index % 8) + "bP" // promotion to bishop
            		 + (index % 8) + (index % 8) + "nP"; // no promotion
             moveList.add(move);
             pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture left (from black perspective)
         pawnMoves = (bP << 9) & blackCaptures & rank1 & ~fileA;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index % 8 + 1) + (index % 8) + "qP" // promotion to queen
            		 + (index % 8 + 1) + (index % 8) + "rP" // promotion to rook
            		 + (index % 8 + 1) + (index % 8) + "bP" // promotion to bishop
            		 + (index % 8 + 1) + (index % 8) + "nP"; // no promotion
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right
         pawnMoves = (bP >> 7) & blackCaptures & rank1 & ~fileH;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 move += (index % 8 - 1) + (index % 8) + "qP" // promotion to queen
            		 + (index % 8 - 1) + (index % 8) + "rP" // promotion to rook
            		 + (index % 8 - 1) + (index % 8) + "bP" // promotion to bishop
            		 + (index % 8 - 1) + (index  %8) + "nP"; // no promotion
        	 moveList.add(move);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
          * En passant
          */
         // left 
         pawnMoves = (wP >> 1) & wP & rank4 & ~fileH & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 move += (index % 8 + 1) + (index  % 8) + "BE";
        	 moveList.add(move);
         }
         // right 
         pawnMoves = (wP << 1) & wP & rank4 & ~fileA & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 move += (index % 8 - 1) + (index  % 8) + "BE";
        	 moveList.add(move);
         }
         
     }
     
     /*
      * Sliding Pieces
      */
     
     // bishops
     // takes (white|black)bishop bitboard as well as (white|black)NoCaptures
     public void bMoves(long bishops, long canGo) {
    	 // all bishop moves
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long nextBishop = bishops & ~(bishops - 1); // grab location of first knight
    	 long moves;
    	 while (nextBishop != 0) {
    		 int bishopPosition = Long.numberOfTrailingZeros(nextBishop); // get position of current bishop
    		 moves = diagonalMoves(bishopPosition) & canGo; // get diagonal moves
    		 long nextMove = moves & ~(moves - 1); // grab first available move
    		 while (nextMove != 0) {
    			 int index = Long.numberOfTrailingZeros(nextMove); // get position of next destination
    			 move += (bishopPosition / 8) + (bishopPosition % 8) + (index / 8) + (index % 8);
    			 moveList.add(move);
    			 moves &= ~nextMove; // remove current move from list
    			 nextMove = moves & ~(moves - 1); // grab next move
    		 }
    		 bishops &= ~nextMove; // remove current bishop from list
    		 nextBishop = bishops & ~(bishops - 1); // grab next bishop
    	 }
     }
     
     // rooks
     // takes (white|black)rooks bitboard as well as (white|black)NoCaptures
     public void rMoves(long rooks, long canGo) {
    	 // all bishop moves
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long nextRook = rooks & ~(rooks - 1); // grab location of first knight
    	 long moves;
    	 while (nextRook != 0) {
    		 int rookPosition = Long.numberOfTrailingZeros(nextRook); // get position of current bishop
    		 moves = rfMoves(rookPosition) & canGo; // get rank and file moves
    		 long nextMove = moves & ~(moves - 1); // grab first available move
    		 while (nextMove != 0) {
    			 int index = Long.numberOfTrailingZeros(nextMove); // get position of next destination
    			 move += (rookPosition / 8) + (rookPosition % 8) + (index / 8) + (index % 8);
    			 moveList.add(move);
    			 moves &= ~nextMove; // remove current move from list
    			 nextMove = moves & ~(moves - 1); // grab next move
    		 }
    		 rooks &= ~nextMove; // remove current bishop from list
    		 nextRook = rooks & ~(rooks - 1); // grab next bishop
    	 }
     }
     
     // queens
     // takes (white|black)queens bitboard as well as (white|black)NoCaptures
     public void qMoves(long queens, long canGo) {
    	 // all queen moves
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long nextQueen = queens & ~(queens - 1); // grab location of first knight
    	 long moves;
    	 while (nextQueen != 0) {
    		 int queenPosition = Long.numberOfTrailingZeros(nextQueen); // get position of current bishop
    		 moves = diagonalMoves(queenPosition) & canGo; // get diagonal moves
    		 moves += rfMoves(queenPosition) & canGo; // get rank and file moves
    		 long nextMove = moves & ~(moves - 1); // grab first available move
    		 while (nextMove != 0) {
    			 int index = Long.numberOfTrailingZeros(nextMove); // get position of next destination
    			 move += (queenPosition / 8) + (queenPosition % 8) + (index / 8) + (index % 8);
    			 moveList.add(move);
    			 moves &= ~nextMove; // remove current move from list
    			 nextMove = moves & ~(moves - 1); // grab next move
    		 }
    		 queens &= ~nextMove; // remove current bishop from list
    		 nextQueen = queens & ~(queens - 1); // grab next bishop
    	 }
    	 
     }
     
     /*
      * Other pieces
      */
     // knights
     public void nMoves(long knights, long canGo) {
    	 // all knight moves
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long nextKnight = knights & ~(knights - 1); // grab location of first knight
    	 long moves;
    	 while (nextKnight != 0) {
    		 int knightPosition = Long.numberOfTrailingZeros(nextKnight); // get position of current bishop
    		 if (knightPosition > 18) {
        		 moves = knightSpan << (knightPosition - 18);
    		 } else {
    			 moves = knightSpan >> (18 - knightPosition);
    		 }
    		 if (knightPosition % 8 < 4) {
                 moves &= (~filesGH & canGo);
             }
             else {
                 moves &= (~filesAB & canGo);
             }
    		 long nextMove = moves & ~(moves - 1); // grab first available move
    		 while (nextMove != 0) {
    			 int index = Long.numberOfTrailingZeros(nextMove); // get position of next destination
    			 move += (knightPosition / 8) + (knightPosition % 8) + (index / 8) + (index % 8);
    			 moveList.add(move);
    			 moves &= ~nextMove; // remove current move from list
    			 nextMove = moves & ~(moves - 1); // grab next move
    		 }
    		 knights &= ~nextMove; // remove current bishop from list
    		 nextKnight = knights & ~(knights - 1); // grab next bishop
    	 }
     }
     
     // kings
     public void kMoves(long king, long canGo) {
    	 // all king moves
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long moves;
    	 int kingPosition = Long.numberOfTrailingZeros(king); // get position of current bishop
    	 
    	 if (kingPosition > 9) {
    		 moves = knightSpan << (kingPosition - 9);
    	 } else {
    		 moves = knightSpan >> (9 - kingPosition);
    	 }
    	 if (kingPosition % 8 < 4) {
    		 moves &= (~filesGH & canGo);
    	 }
    	 else {
    		 moves &= (~filesAB & canGo);
    	 }
    	 long nextMove = moves & ~(moves - 1); // grab first available move
    	 while (nextMove != 0) {
    		 int index = Long.numberOfTrailingZeros(nextMove); // get position of next destination
    		 move += (kingPosition / 8) + (kingPosition % 8) + (index / 8) + (index % 8);
    		 moveList.add(move);
    		 moves &= ~nextMove; // remove current move from list
    		 nextMove = moves & ~(moves - 1); // grab next move
    	 }
     }
     
     /*
      *  Castling
      *  Takes boolean flag for white or black player, rook bitboard, and
      *  boolean flags to determine is castling is still possible
      *   
      */
     public void cMoves(boolean player, long rooks, boolean kSide, boolean qSide) {
    	 String move = ""; // concatenated list of all possible moves as x1y1x2y2
    	 if (player == false) { // white player
    		 if (kSide && ((occupied & ((1L << 61) | (1L << 62))) == 0)) { // check king side castling enabled and path clear
    			 move += "7476";
    			 moveList.add(move);
    		 }
    		 if (qSide && ((occupied & ((1L << 57) | (1L << 58) | (1L << 59))) == 0)) { // check queen side castling enabled and path clear
    			 move += "7472";
    			 moveList.add(move);
    		 }
    	 } else { // black player
    		 if (kSide && ((occupied & ((1L << 5) | (1L << 6))) == 0)) { // check king side castling enabled and path clear
    			 move += "0406";
    			 moveList.add(move);
    		 }
    		 if (qSide && ((occupied & ((1L << 1) | (1L << 2) | (1L << 3))) == 0)) { // check queen side castling enabled and path clear
    			 move += "0402";
    			 moveList.add(move);
    		 }
    	 }
     }
     
     /*
      * Movements for sliding piece
      */
     
     // rank and file slides, takes integer position
     public long rfMoves(int position) {
    	 // all sliding piece moves along ranks and files
    	 long bitPos = 1L << position; // create bitstring of 1 and shift it to proper position
         long possRanks = (occupied - 2 * bitPos) ^ Long.reverse(Long.reverse(occupied) - 2 * Long.reverse(bitPos));
         long possFiles = ((occupied & fileMasks[position % 8]) - (2 * bitPos)) ^ Long.reverse(Long.reverse(occupied & fileMasks[position % 8]) - (2 * Long.reverse(bitPos)));
         return (possRanks & rankMasks[position / 8]) | (possFiles & fileMasks[position % 8]);
     }
     
     // diagonal and anti-diagonal slides
     public long diagonalMoves(int position) {
    	 // all sliding piece moves along diagonal and anti-diagonals
    	 long bitPos = 1L << position; // create bitstring of 1 and shift it to proper position
         long possDiagonal = ((occupied & diagonalMasks[(position / 8) + (position % 8)]) - (2 * bitPos)) ^ Long.reverse(Long.reverse(occupied & diagonalMasks[(position / 8) + (position % 8)]) - (2 * Long.reverse(bitPos)));
         long possAntiDiagonal = ((occupied&antiDiagonalMasks[(position / 8) + 7 - (position % 8)]) - (2 * bitPos)) ^ Long.reverse(Long.reverse(occupied & antiDiagonalMasks[(position / 8) + 7 - (position % 8)]) - (2 * Long.reverse(bitPos)));
         return (possDiagonal & diagonalMasks[(position / 8) + (position % 8)]) | (possAntiDiagonal & antiDiagonalMasks[(position / 8) + 7 - (position % 8)]);
     }
     
     /*
      * Unsafe positions
      * Determines all the positions which the opponent can move to
      * Takes boolean flag to label player for pawn shifts as well as
      * all opponent piece position bitboards
      */
     public long unsafe(boolean player, long oppP, long oppN, long oppB, long oppR, long oppQ, long oppK) {
    	 long unsafe; // all unsafe positions for player
         long possMoves; // all possible opponents moves
         
         // attacks from pawns differ depending on player
         if (player = true) { // true = black
        	 unsafe = ((oppP >> 7) & ~fileA); //pawn capture right
        	 unsafe |= ((oppP >> 9) & ~fileH);//pawn capture left
         } else {
        	 unsafe = ((oppP << 7) & ~fileA); //pawn capture left
        	 unsafe |= ((oppP << 9) & ~fileH);//pawn capture right
         }
         
         // attacks from knight
         long nextPiece = oppN & ~(oppN - 1);
         while(nextPiece != 0) {
        	 int knightPosition = Long.numberOfTrailingZeros(nextPiece);
        	 
        	 if (knightPosition > 18) {
        		 possMoves = knightSpan << (knightPosition - 18);
        	 } else {
        		 possMoves = knightSpan >> (18 - knightPosition);
        	 }
        	 
        	 if (knightPosition % 8 < 4) {
        		 possMoves &= ~filesGH;
        	 } else {
        		 possMoves &= ~filesAB;
        	 }
        	 
        	 unsafe |= possMoves;
        	 oppN &= ~nextPiece;
        	 nextPiece = oppN & ~(nextPiece - 1);
         }
         
         // attacks from bishops and diagonal queens
         long oppQB = oppQ | oppB;
         nextPiece = oppQB & ~(oppQB - 1);
         while (nextPiece != 0) {
             int qbPosition=Long.numberOfTrailingZeros(nextPiece);
             possMoves = diagonalMoves(qbPosition);
             unsafe |= possMoves;
             oppQB &= ~nextPiece;
             nextPiece = oppQB & ~(oppQB-1);
         }
         
         // attacks from rooks and rank/file queens
         long oppQR = oppQ | oppR;
         nextPiece = oppQR & ~(oppQR-1);
         while(nextPiece != 0) {
             int qrPosition=Long.numberOfTrailingZeros(nextPiece);
             possMoves=rfMoves(qrPosition);
             unsafe |= possMoves;
             oppQR &= ~nextPiece;
             nextPiece = oppQR & ~(oppQR-1);
         }
         
         // attacks from king
         int kPosition = Long.numberOfTrailingZeros(oppK);
         if (kPosition > 9) {
             possMoves = kingSpan << (kPosition - 9);
         } else {
             possMoves = kingSpan >> (9 - kPosition);
         }
         if (kPosition % 8 < 4) {
             possMoves &= ~filesGH;
         }
         else {
             possMoves &= ~filesAB;
         }
         unsafe |= possMoves;
         return unsafe;
     }
     
}
