package chessEngine;

//TODO re-analyze pawn movements, might be able to make generic function to handle while loops

/*
 * Class generates all possible moves for a player. Bitboard masks are used to
 * control for legality of moves. Masks were pre-generated by Logic Crazy, some masks
 * are in hex representations to conserve space and readability of code.
 * 
 * Piece position bitboards are generated by BoardGen class. All piece move functions are
 * generalized except pawns due to pawns being direction dependent.
 * 
 * Based on Logic Crazy chess engine: https://www.youtube.com/channel/UCmMjMHTeUEBJJZhxix-N-yg
 */

public class GenerateMoves {
	long fileA=72340172838076673L; // prevent bad pawn moves
    long fileH=-9187201950435737472L; // prevent bad pawn moves
    long filesAB=217020518514230019L; // prevent bad knight moves
    long filesGH=-4557430888798830400L; // prevent bad knight moves
    long rank1=-72057594037927936L; // used for pawn promotion
    long rank8=255L; // used for pawn promotion
    long rank4=1095216660480L; // used for en passant
    long rank5=4278190080L; // used for en passant
    long occupied; // holds all occupied locations
    long empty; // holds all empty locations on board
    long whiteCaptures; // locations of bP, bN, bB, bR, bQ
    long blackCaptures; // locations of wP, wN, wB, wR, wQ
    long whiteNoCapture; // locations of wP, wN, wB, wR, wQ, wK, bK
    long blackNoCapture; // locations of bP, bN, bB, bR, bQ, bK, wK
    long enpassant; // holds location of possible en passant
    long rankMasks[] = { 
    		0xFFL, 0xFF00L, 0xFF0000L, 0xFF000000L, 0xFF00000000L, 
    		0xFF0000000000L, 0xFF000000000000L, 0xFF00000000000000L
     }; // masks for all ranks used for sliding piece moves (ordered: 1 to 8)
     long fileMasks[] = {
    		 0x101010101010101L, 0x202020202020202L, 0x404040404040404L, 0x808080808080808L,
    		 0x1010101010101010L, 0x2020202020202020L, 0x4040404040404040L, 0x8080808080808080L
     }; // masks for all files used for sliding piece moves (ordered: A to H)
     long diagonalMasks[] = {
    		 0x1L, 0x102L, 0x10204L, 0x1020408L, 0x102040810L, 0x10204081020L, 0x1020408102040L,
    		 0x102040810204080L, 0x204081020408000L, 0x408102040800000L, 0x810204080000000L,
    		 0x1020408000000000L, 0x2040800000000000L, 0x4080000000000000L, 0x8000000000000000L
     }; // masks for all diagonals used for sliding piece moves (ordered: from top left to bottom right)
     long antiDiagonalMasks[] = {
    		 0x80L, 0x8040L, 0x804020L, 0x80402010L, 0x8040201008L, 0x804020100804L, 0x80402010080402L,
    		 0x8040201008040201L, 0x4020100804020100L, 0x2010080402010000L, 0x1008040201000000L,
    		 0x804020100000000L, 0x402010000000000L, 0x201000000000000L, 0x100000000000000L
     }; //masks for all anti-diagonals used for sliding piece moves (ordered: from top right to bottom left)
     
     
     public String whiteMoves(long wP, long wN, long wB, long wR, long wQ, long wK, long bP, long bN, long bB, long bR, long bQ, long bK) {
    	 //TODO needs testing
    	 // wpMoves() + rankMoves() + fileMoves() + diagonalMoves() + antidiagonalMoves()
    	 String moveList; // concatenated list of all possible moves
    	 
    	 occupied = (wP | wN | wB | wR | wQ | wK | bP | bN | bB | bR | bQ | bK);
    	 empty = ~occupied;
    	 whiteNoCapture = ~(wP | wN | wB | wR | wQ | wK | bK);
    	 whiteCaptures = (bP | bN | bB | bR | bQ);
    	 moveList = wpMoves()
    			 + rankMoves() 
    			 + fileMoves() 
    			 + diagonalMoves() 
    			 + antidiagonalMoves();
    	 
    	 return moveList;
     }
     
     public String blackMoves(long wP, long wN, long wB, long wR, long wQ, long wK, long bP, long bN, long bB, long bR, long bQ, long bK) {
    	 //TODO needs testing
    	 // bpMoves() + rankMoves() + fileMoves() + diagonalMoves() + antidiagonalMoves()
    	 String moveList; // concatenated list of all possible moves as x1y1x2y2

    	 occupied = (wP | wN | wB | wR | wQ | wK | bP | bN | bB | bR | bQ | bK);
    	 empty = ~occupied;
    	 blackNoCapture = ~(bP | bN | bB | bR | bQ | bK | wK);
    	 blackCaptures = (wP | wN | wB | wR | wQ);
    	 moveList = bpMoves()
    			 + rankMoves() 
    			 + fileMoves() 
    			 + diagonalMoves() 
    			 + antidiagonalMoves();
    	 
    	 return moveList;
     }
     
     public void wpMoves(long wP, long bP) {
    	 //TODO needs testing
    	 // all moves for white pawns
    	 String moveList = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long pawnMoves; // bitboard for pawn destinations
    	 long nextMove; // bitboard to test each move
    	 
    	 /*
    	  * Forward Progress
    	  */
    	 
    	 // move forward 1
    	 pawnMoves =(wP >> 8) & empty & ~rank8; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 + 1) + (index % 8) + (index / 8) + (index % 8);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 // move forward 2
         pawnMoves =(wP >> 16) & empty & (empty >> 8) & rank4; // only allow if path is clear and destination is rank 4
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 + 2) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
    	  * Captures
    	  */
         
    	 // capture left (from white perspective)
         pawnMoves = (wP >> 9) & whiteCaptures & ~rank8 & ~fileH; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 + 1) + (index % 8 + 1) + (index / 8) + (index % 8);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right (from white perspective)
         pawnMoves = (wP >> 7) & whiteCaptures & ~rank8 & ~fileA; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 + 1) + (index % 8 - 1) + (index / 8) + (index % 8);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 /*
    	  * Promotions
    	  */
         
         // forward
         pawnMoves = (wP >> 8) & empty & rank8;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
             moveList += (index % 8) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8) + (index  %8) + "NP"; // no promotion
             pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture left (from white perspective)
         pawnMoves = (wP >> 9) & whiteCaptures & rank8 & ~fileH;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index % 8 - 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 - 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 - 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 - 1) + (index  %8) + "NP"; // no promotion
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right
         pawnMoves = (wP >> 7) & whiteCaptures & rank8 & ~fileA;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index % 8 + 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 + 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 + 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 + 1) + (index  %8) + "NP"; // no promotion
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
    	 /*
    	  * En passant
    	  */
         // left 
         pawnMoves = (wP << 1) & bP & rank5 & ~fileA & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 moveList += (index % 8 - 1) + (index  % 8) + "E";
         }
         // right 
         pawnMoves = (wP >> 1) & bP & rank5 & ~fileH & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 moveList += (index % 8 + 1) + (index  % 8) + "E";
         }
     }
     
     public void bpMoves(long bP, long wP) {
    	 //TODO needs testing
    	 // all moves for black pawns
    	 String moveList = ""; // concatenated list of all possible moves as x1y1x2y2
    	 long pawnMoves; // bitboard for pawn destinations
    	 long nextMove; // bitboard to test each move
    	 
    	 /*
    	  * Forward Progress
    	  */
    	 
    	 // move forward 1
    	 pawnMoves =(bP << 8) & empty & ~rank1; // see promotions for rank1
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 - 1) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }

         // move forward 2
         pawnMoves =(bP << 16) & empty & (empty << 8) & rank5; // only allow if path is clear and destination is rank 5
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 - 2) + (index % 8) + (index / 8) + (index % 8); // add move to list
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
    	  * Captures
    	  */
         
    	 // capture left (from black perspective)
         pawnMoves = (bP << 9) & blackCaptures & ~rank1 & ~fileA; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 - 1) + (index % 8 - 1) + (index / 8) + (index % 8);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right (from black perspective)
         pawnMoves = (bP << 7) & whiteCaptures & ~rank8 & ~fileH; // see promotions for rank8
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index / 8 - 1) + (index % 8 + 1) + (index / 8) + (index % 8);
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }

         /*
    	  * Promotions
    	  */
         // forward
         pawnMoves = (bP << 8) & empty & rank8;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
             moveList += (index % 8) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8) + (index  %8) + "NP"; // no promotion
             pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture left (from black perspective)
         pawnMoves = (bP << 9) & blackCaptures & rank1 & ~fileA;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index % 8 + 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 + 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 + 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 + 1) + (index  %8) + "NP"; // no promotion
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         // capture right
         pawnMoves = (bP >> 7) & blackCaptures & rank1 & ~fileH;
         nextMove = pawnMoves & ~(pawnMoves - 1); // grab next available destination
         while (nextMove != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of first destination
        	 moveList += (index % 8 - 1) + (index % 8) + "QP" // promotion to queen
            		 + (index % 8 - 1) + (index % 8) + "RP" // promotion to rook
            		 + (index % 8 - 1) + (index % 8) + "BP" // promotion to bishop
            		 + (index % 8 - 1) + (index  %8) + "NP"; // no promotion
        	 pawnMoves &= ~nextMove; // remove added move from list of remaining possibilities
        	 nextMove = pawnMoves & ~(pawnMoves - 1); // remove all moves but one
         }
         
         /*
          * En passant
          */
         // left 
         pawnMoves = (wP >> 1) & wP & rank4 & ~fileH & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 moveList += (index % 8 + 1) + (index  % 8) + "E";
         }
         // right 
         pawnMoves = (wP << 1) & wP & rank4 & ~fileA & enpassant; // checks if enpassant is possible
         if (pawnMoves != 0) {
        	 int index = Long.numberOfTrailingZeros(nextMove); // get position of destination
        	 moveList += (index % 8 - 1) + (index  % 8) + "E";
         }
     }
     
     public void rankMoves() {
    	 //TODO code and test
    	 // all sliding piece moves within rank
     }
     
     public void fileMoves() {
    	 //TODO code and test
    	 // all sliding piece moves within file
     }
     
     public void diagonalMoves() {
    	 // TODO code and test
    	 // all sliding piece moves along diagonal
     }
     
     public void antiDiagonalMoves() {
    	 // TODO code and test
    	 // all sliding piece moves along anti-diagonal
     }
}
